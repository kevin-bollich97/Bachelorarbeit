\chapter{Herausforderungen}
\label{anpassung}

In diesem Kapitel werden Herausforderungen, die mit dem Logging in Verbindung stehen, erläutert. 
Dabei sollen Anti-Pattern vorgestellt werden, die beim Logging vermieden werden sollen. 
Hier wird zu Beginn erläutert, was ein Anti-Pattern überhaupt ist. 
Anschließend werden die unterschiedlichen Kategorien von Anti-Pattern näher definiert und jeweils ein Lösungsvorschlag gegeben. \\
Im zweiten Teil diesen Kapitels werden Logging code smells genannt. 
Dabei wird zu Beginn, wie im ersten Teil diesen Kapitels, eine erklärung geliefert.
Anschließend werden die unterschiedlichen Kategorien der Logging code smells genauer erklärt. 

\section{Anti-Pattern}
Unter einem Anti-Pattern wird ein schlechtes (Logging-)Verhalten verstanden, dass keinen vollständigen Nutzen für die Entwicklung und Wartung bietet, sondern auch Schwierigkeiten mit sich bringen.
Durch diese hier vorgestellten Pattern, wird das Logging erschwert.
Der ausgegebene Logging-Code wird z.B. schlechter zu lesen oder enthält sogar widersprüchliche Aussagen.   
Diese Pattern wurden in der Studie \citetitle*{chenCharacterizingDetectingAntipatterns2017} \cite{chenCharacterizingDetectingAntipatterns2017} erarbeitet.
Dabei wurden drei bekannte Open-Source Projekte nach ihrem Log-Verhalten analysiert. \\
In der Studie wurden fünf \textit{Anti-Pattern} gefunden. 
Alle fünf werden in diesem Kapitel ausführlich beschrieben. 
Wichtig sind hier die Lösungen für die \textit{Pattern}. Die fünf \textit{Pattern} sind: \cite{chenCharacterizingDetectingAntipatterns2017}
\begin{itemize}
    \item Null Objekt
    \item Explizite Typumwandlung
    \item Falsches Log-Level
    \item Doppelter Code
    \item Schlechtes Ausgabeformat
\end{itemize}

\subsection{Null Objekt}

Die dynamisch generierten Werte in Log-Nachrichten werden während der Laufzeit generiert.
Dabei kann es passieren, dass die Werte \textit{null} sind. 
In manchen Fällen kann das zu einer \textit{NullPointerException} führen und die Anwendung zum Absturz bringen. 
Ein Beispiel für diesen Fall ist in Quellcode \ref{codeNullPointer} zu sehen. 
\begin{lstlisting}[caption=Null Objekt \cite{chenCharacterizingDetectingAntipatterns2017}, label=codeNullPointer]
if(proxy != null && invocationHandler != null && invocationHandler instanceOf Closeable)
...
} else {
    Log.error("Could not get invocation handler " + invocationHandler + "for proxy " + proxy + ", or invocation handler is not closeable.");
...
}
\end{lstlisting} 
Obwohl in diesem Beispiel kein Absturz durch die NullPointerException erzeugt wird, werden durch diese Art von Logging wichtige Informationen nicht mitgeliefert.
In diesem Beispiel wird der Fall, dass die Variable \textit{proxy} null sein kann, nicht behandelt. 
Damit eine korrekte Log-Nachricht erstellt werden kann, muss der spezielle Fall von der Variable \textit{proxy} abgefangen werden. 
Dies kann z.B. in einem \textit{else-if} abgefangen werden. 
Wenn \textit{proxy} dann \textit{null} ist, kann ein Log für speziell diesen Fall geloggt werden. 
Mit dem Abfangen solcher Fälle kann der Wartungsaufwand stark reduziert werden. 
Denn so enthalten Log-Nachrichten die wirklich relevanten Informationen und sind nicht mehrdeutig zu verstehen. \cite{chenCharacterizingDetectingAntipatterns2017}


\subsection{Explizite Typumwandlung}

Die explizite Typumwandlung ist eine Möglichkeit in vielen Programmiersprachen, um ein Objekt in einen speziellen Typ umzuwandeln. 
Um eine explizite Typumwandlung zu erzwingen, muss der Typ in Klammern vor das bestimmt Objekt geschrieben werden. 
Im Quellcode \ref{codeExpliziteUmwandlung} wird die Variable \textit{diskBlockInfo} in einen \textit{Block} umgewandelt.
Die explizite Typumwandlung wird im Beispiel mit der Anweisung \textit{(Block)} umgesetzt.
Beim Umwandeln besteht die Gefahr, dass eine \textit{ClassCastException} geworfen wird und einen Absturz der Software verursacht.  
Da Logging nicht essenziell für die Funktionalität ist, sollten solche Typumwandlungen im Logging vermieden werden. 
Die Lösung für dieses Beispiel wäre die explizite Typumwandlung zu entfernen und das System während der Laufzeit selbst entscheiden zu lassen, was für ein Typ das Objekt ist. \cite{chenCharacterizingDetectingAntipatterns2017}

\begin{lstlisting}[caption=Explizite Umwandlung \cite{chenCharacterizingDetectingAntipatterns2017}, label=codeExpliziteUmwandlung]
DataNode.LOG.warn("Added missing block to memory " + (Block)diskBlockInfo);
\end{lstlisting}

\subsection{Falsches Log-Level}

In dieser Projektarbeit wurde das richtige Log-Level für die speziellen Situationen schon in Kapitel \ref{kap:dasRichtigeLogLevel} beschrieben. 
Bei der Suche nach dem richtigen Log-Level kann es jedoch passieren, dass Entwickler das Log-Level nachträglich ändern oder den Inhalt dieser Nachricht noch verändern. 

Im Quellcode \ref{codeFalschesLogLevel} enthält der Code widersprüchliche Informationen. 
Denn das Log-Level entspricht nicht dem, was in der Nachricht beschrieben wird. 
Das Log-Level sagt, dass es sich um ein \textit{info} Log handelt. 
Im Gegensatz dazu, spricht der statische Text von einem \textit{debug} Log.
Dies kann für Verwirrung bei der Entwicklung und auch bei der Wartung führen. 
Denn wenn in Produktion das Log-Level auf \textit{info} gesetzt wird, taucht plötzlich diese Nachricht auf, die eigentlich nur für die Entwicklung relevant ist. 
In diesem Beispiel wäre die Lösung, dass das Log-Level im Logger auf \textit{debug} geändert wird. \cite{chenCharacterizingDetectingAntipatterns2017} 

\begin{lstlisting}[caption=Falsches Log-Level \cite{chenCharacterizingDetectingAntipatterns2017}, label=codeFalschesLogLevel]
LOG.info("DEBUG --- Container FINISHED: " + containerId);
\end{lstlisting}

\subsection{Doppelter Code}
\label{kap:loggingCodeSmell}
Doppelter Code gehört zu den \textit{Logging code smells}.
\textit{Logging code smells} beschreiben schlechte Entscheidungen in Softwaredesign und der Entwicklung, die für das Logging getroffen wurden. 
Logging-Code muss einfach verstanden werden und klare Informationen liefern. 
Dies geschieht mit statischem Text, aber auch mit weiteren dynamischen Komponenten. 
Wenn der Logging-Code zu lang wird, dann steigt die Schwierigkeit den Code zu verstehen und zu warten. 
Im Quellcode \ref{codeCodeSmell} kann man einen \textit{code smell} sehen. 
Denn in dem Beispiel wird doppelter Code verwendet. 
Die Methode \textit{getRemoteName()} liefert den gleichen Wert wie der dynamische Teil im Logging-Abschnitt in Zeile 7. 
Beim Entwickeln von Software sollte darauf geachtet werden, Redundanzen zu vermeiden. 
Auch für das Logging sollte dies beachtet werden. 
Für diesen Fall wäre die Lösung, dass der Aufruf in Zeile 7 (\textit{channel.socket().getRemoteSocketAddress()}) durch den Methodenaufruf \textit{getRemoteName()} ersetzt wird. \cite{chenCharacterizingDetectingAntipatterns2017}

\begin{lstlisting}[caption=Logging code smell \cite{chenCharacterizingDetectingAntipatterns2017}, label=codeCodeSmell]
public String getRemoteName() {
    return channel.socket().getRemoteSocketAddress().toString();
} 
...
public SocketTransceiver(SocketChannel channel) {
    this.channel = channel;
    LOG.info("open to-"+channel.socket().getRemoteSocketAddress());
}
\end{lstlisting}

\subsection{Schlechtes Ausgabeformat}

Die Verwendung von Logs in der Wartung und Entwicklung kann den Prozess erleichtern und gleichzeitig stark beschleunigen. 
Jedoch sollte die Ausgabe dabei etwas liefern, dass für den Nutzer verständlich ist. 
In Quellcode \ref{codeSchlechtesAusgabeformat} wird im Log ein Byte array mitgeliefert. 
Dies ist ein für Menschen nicht verständliches Format. 
Die Lösung in diesem Fall ist der Aufruf der \textit{toString()} Methode. \cite{chenCharacterizingDetectingAntipatterns2017}

\begin{lstlisting}[caption=Schlechtes Ausgabeformat \cite{chenCharacterizingDetectingAntipatterns2017}, label=codeSchlechtesAusgabeformat]
protected ClientScanner(final byte[][] columns, final byte [] startRow, ... ){
...
LOG.debug("Creating scanner over " + Bytes.toString(tableName) +
" starting at key '" + startRow + "'");
...
}
\end{lstlisting}


\section{Logging code smells}

In Kapitel \ref{kap:loggingCodeSmell} wurde schon  erwähnt, dass Redundanzen im Logging-Code vermieden werden sollen. 
Jedoch können im Logging noch andere \textit{code smells} entdeckt werden. 
Diese können zu Problemen im Bugtracking führen. 
Denn einige \textit{code smells} erzeugen inkonsequenten Inhalt und verwirren somit die Entwickler und Administratoren. \\

Der Begriff \textit{smell} stammt von den Autoren Martin Fowler und Kent Beck.
Im Buch \cite{martinRefactoringImprovingDesign2018} beschreiben die beiden wie dieser Begriff entstanden ist. 
Das \textit{smell} in \textit{code smell} stammt von der Großmutter von Kent Beck, die über die volle Windel der Tochter von Beck dieses Zitat ausgesprochen hatte: \cite{martinRefactoringImprovingDesign2018}
\begin{quote}
    \glqq If it stinks, change it.\grqq{}
\end{quote}
Dabei entdeckten die beiden Autoren, dass es bei der Entwicklung so ähnlich ist. 
Wenn etwas \glqq stinkt\grqq{}, dann sollte es verändert werden. 
Das Stinken beschreibt hier das Gefühl, dass etwas mit dem Code nicht ganz stimmt oder einfach nicht verständlich ist. \\

In diesem Kapitel werden \textit{code smells} beschrieben, die beim Logging entstehen können. 
Es werden fünf \textit{code smells} vorgestellt, die alle in der Studie \citetitle*{liDLFinderCharacterizingDetecting2019} \cite{liDLFinderCharacterizingDetecting2019} gefunden wurden. 
In dieser Studie wurden vier Open-Source Projekte durchsucht, um \textit{code smells} im Logging zu finden. 
Die fünf \textit{code smells} sind: \cite{liDLFinderCharacterizingDetecting2019}

\begin{itemize}
    \item Uneindeutige Informationen in Catch-Anweisungen
    \item Inkonsequente Informationen im Error-Handling
    \item Falsche Log-Nachricht
    \item Inkonsistentes Log-Level
    \item Doppelter Log in Polymorphismus
\end{itemize}

\subsection{Uneindeutige Informationen in Catch-Anweisungen}

Log-Nachrichten liefern Informationen über den Verlauf der Software.
Wenn diese Informationen lückenhaft oder nicht eindeutig sind, dann sinkt der dadurch gewonnene Mehrwert.
In \textit{try-catch-Anweisungen} werden definierte \textit{Exceptions} abgefangen. 
Dabei können, wie in Quellcode \ref{codeUnzureichendeInformationenInCatch} zu sehen ist, mehrere \textit{Exceptions} abgefangen werden. 
In dem Quellcode werden die beiden Exceptions \textit{IllegalArgumentException} und \textit{IllegalAccessException} abgefangen. 
Das bietet die Möglichkeit, diese beiden Fehlerquellen individuell zu behandeln und schnell die Ursache des Fehlers zu finden. 
Jedoch kann es passieren, dass die beiden Anweisungen den gleichen Text loggen.
Durch diese entstandene Uneindeutigkeit kann ein entstandener Fehler nicht mehr eindeutig zugeordnet werden. \cite{liDLFinderCharacterizingDetecting2019}

\begin{lstlisting}[caption=Uneindeutige Informationen in Catch-Anweisungen \cite{liDLFinderCharacterizingDetecting2019}, label=codeUnzureichendeInformationenInCatch]
catch (final IllegalArgumentException e) {
    s_logger.error("Error initializing command " + 
        cmd.getCommandName() + ", field " + field.getName() + " is not accessible.")
} catch (final IllegalAccessException e) {
    s_logger.error("Error initializing command " + cmd.getCommandName() +
    ", field " + field.getName() + " is not accesible.");
}
\end{lstlisting}

\subsection{Inkonsequente Informationen im Error-Handling}

In der Studie beschreiben die Autoren, dass identische Logging-Anweisungen häufig inkonsequente Informationen liefern. 
Ein Beispiel dafür ist in Quellcode \ref{codeInkonsequenteInformationenInError} zu sehen. 
Hier sind zwei identische \textit{catch-Anweisungen} implementiert. 
Jedoch liefern beide unterschiedliche Informationen. 
Die erste catch-Anweisung liefert den \textit{stack trace} und die zweite liefert nur die \textit{Exception} zurück. 
Logging-Anweisungen sollten klar definiert sein und müssen immer die relevanten Informationen liefern. 
Damit bei der Fehlersuche effizient Fehler gefunden werden können, müssen die Log-Nachrichten identischen Inhalt liefern. \cite{liDLFinderCharacterizingDetecting2019}

\begin{lstlisting}[caption=Inkonsequente Informationen in Error-Handling \cite{liDLFinderCharacterizingDetecting2019}, label=codeInkonsequenteInformationenInError]
public class CreatePortForwardingRuleCmd{
    ...
    } catch (NetworkRuleConflictException ex) {
        s_logger.info("Network rule conflict: " + ex.getMessage());
    }
    ...
    } catch (NetworkRuleConflictException ex) {
        s_logger.info("Network rule conflict: " + ex);
    }
}
    
\end{lstlisting}

\subsection{Falsche Log-Nachricht}

Bei der Softwareentwicklung kann es vorkommen, dass einzelne Code-Stellen kopiert werden. 
Dabei vergessen Entwickler häufig, die Log-Nachrichten ebenfalls anzupassen. 
So ein Beispiel kann in Quellcode \ref{codeFalscheLogNachricht} gesehen werden. 
In dem Beispiel sind die Methoden \textit{doScaleUp} und \textit{doScaleDown} definiert. 
Beide Methoden sind sich in Aufbau und Verhalten sehr ähnlich. 
Daher wurde der Code kopiert und an den richtigen Stellen angepasst. 
Jedoch wurde vergessen, den statischen Text der Log-Nachricht anzupassen. \cite{liDLFinderCharacterizingDetecting2019} 


\begin{lstlisting}[caption=Falsche Log-Nachricht \cite{liDLFinderCharacterizingDetecting2019}, label=codeFalscheLogNachricht]
public void doScaleUp() {
    ...
    s_logger.error("Can not find the groupid " + groupid + 
        " for scaling up");
}
public void doScaleDown() {
    ...
    s_logger.error("Can not find the groupid " + groupid + 
        " for scaling up");
}
\end{lstlisting}

\subsection{Inkonsistentes Log-Level}

In Kapitel \ref{kap:dasRichtigeLogLevel} wurde darauf eingegangen, wie sich für das richtige Log-Level entschieden wird. 
Wie in dem Kapitel beschrieben, können für die einzelnen Fälle verschiedene Entscheidungen getroffen werden. 
Manchmal können auch für einen Fall mehrere Log-Level genutzt werden. 
Wichtig ist hierbei, dass eine Entscheidung im gesamten Quellcode durchgesetzt wird.
Denn es sollte für einen speziellen Fall klar sein, welches Log-Level genutzt wird. \\
In Quellcode \ref{codeInkonsistentesLogLevel} sind zwei \textit{if-Anweisungen} definiert. 
Beide sind identisch, jedoch an unterschiedlichen Stellen im Code definiert.
Obwohl beide identisch sind, wird nicht das gleiche Log-Level verwendet. 
Damit Verwirrungen vermieden werden, sollten solche \textit{code smells} vermieden werden. 
Diese \textit{code smells} können verhindert werden, indem das Team für diese einzelne Fälle definiert, welches Log-Level genutzt werden soll. 

\begin{lstlisting}[caption=Inkonsistentes Log-Level \cite{liDLFinderCharacterizingDetecting2019}, label=codeInkonsistentesLogLevel]
if(!StorageService.instance.isJoined()) {
    logger.info("Cleanup cannot run before a node 
        has joined the ring");
    return;  
}
if(!StorageService.instance.isJoined()) {
    logger.error("Cleanup cannot run before a node 
        has joined the ring");
    return;  
}
\end{lstlisting}

\subsection{Doppelter Log in Polymorphismus}

Die Vererbung in objektorientierten Programmiersprachen kann für das Logging einen erhöhten Wartungsaufwand hervorbringen. 
Durch die Vererbung können Unterklassen Methoden überschreiben. 
Beim Überschreiben kann es passieren, dass die Unterklassen eigene Log-Nachrichten implementieren, diese sich aber inhaltlich nicht unterscheiden. 
Ein Beispiel dafür kann in Quellcode \ref{codeDoppelterLogInPoli} gesehen werden. 
In dem Beispiel sind zwei Klassen, die von der gleichen Klasse und dem gleichen Interface erben. 
Beide Klassen überschreiben die Methoden des Interfaces. 
Die überschriebenen Methoden loggen jedoch identischen Inhalt. 
Durch dieses Duplikat, steigt der Wartungsaufwand der Software. 
Um den Wartungsaufwand zu minimieren, sollten diese \textit{code smells} verhindert werden. 

\begin{lstlisting}[caption=Doppelter Log \cite{liDLFinderCharacterizingDetecting2019}, label=codeDoppelterLogInPoli]
public class PowerShellFencer extends Configured implements FenceMethod {
    ...
    } catch (InterruptedException ie) {}
        LOG.warn("Interrupted while waiting for fencing command: " 
        + ps1script);
    }
public class PowerShellFencer extends Configured implements FenceMethod {
    ...
    } catch (InterruptedException ie) {}
        LOG.warn("Interrupted while waiting for fencing command: " 
        + cmd);
    }
\end{lstlisting}


%\section{Welche Topics sollten immer oder gar nicht geloggt werden?}


% \section{Vermeidung von Redundanzen}
% % Es sollen doppelte Log Nachrichten vermieden werden
% Anti Pattern ChenAntiPatterns

%\section{Evolution von Log Nachrichten}
% Welche Loginformationen werden oft geändert? 


\section{Überblick}

In diesem Kapitel wurden Herausforderungen beschrieben, die beim Logging beachtet werden müssen. 
Das Kapitel teilt sich in zwei Teile auf. 
Zu Beginn werden fünf Logging Anti-Pattern vorgestellt. 
Logging Anti-Pattern beschreiben schlechtes Verhalten beim Logging.
Im zweiten Teil werden dann Logging code smells beschrieben. 
In dem Fall sind es ebenfalls fünf Kategorien die gezeigt werden. 
Logging Anti-Pattern und Logging code smells sollten vermieden werden, um ein gutes Logging zu erhalten. 
